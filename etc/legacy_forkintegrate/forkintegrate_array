#!/bin/ksh
#                      forkintegrate
#
# enables  multi-tasking by splitting the INTEGRATE step of
# xds into independent jobs. Each job is carried out by the
# Fortran program mintegrate or mintegrate_par started by
# this script as a background process with a different set
# of input parameters.
#
# 'forkintegrate' is called by xds (or xds_par) in the
# INTEGRATE step using the Fortran instruction
# CALL SYSTEM('forkintegrate fframe ni ntask niba0 maxcpu'),
#    fframe ::id number of the first data image
#    ni     ::number of images in the data set
#    ntask  ::total number of jobs
#    niba0  ::minimum number of images in a batch
#    maxcpu ::maximum number of processors used by each job
#
# Clearly, this can only work if forkintegrate, mintegrate,
# and mintegrate_par are correctly installed in the search
# path for executables.
#
# W.Kabsch and K.Rohm     Version Februar 2005
# NOTE: No blanks allowed adjacent to the = signs !!!

# K.Diederichs 9/2005 modification of this script make job
# execution on remote hosts work in networked (NFS) environment.
# The list of hosts where the jobs should run, of course, needs
# to be adapted to each installation.

# This has since been modified to run on a new cluster, using qsub
# do it could be kinda messy. You have been warned. Based on a script
# provided by Frederik Ferner:
# 
# 11022001 AWA extended to cope with only gda allowed to use the high.q
#
# cat $PE_HOSTFILE

install=/dls_sw/apps/XDS/etc

echo "Forkintegrate started at `date`" >> .forkintegrate.debug

if test $USER$FAST_DP_FORKINTEGRATE = 'gda1' ; then
  queue=high.q # this should happen no more
elif test $USER$FAST_DP_FORKINTEGRATE = 'gda21' ; then
  queue="high.q -l h_rt=00:20:00" # was @@com09; 20150616 undo this
else
  queue="medium.q -l h_rt=00:20:00"
fi

fframe=$1 #id number of the first image
ni=$2     #number of images in the data set
ntask=$3  #total number of jobs
niba0=$4  #minimum number of images in a batch
maxcpu=$5 #maximum number of processors used by each job
          #maxcpu=1: use 'mintegrate' (single processor)
          #maxcpu>1: use 'mintegrate_par' (openmp version)

echo $1 $2 $3 $4 $5 > .forkintegrate.params

minitask=$(($ni / $ntask)) #minimum number of images in a job
mtask=$(($ni % $ntask))    #number of jobs with minitask+1 images
pids=""                    #list of background process ID's
nba=0
litask=0
itask=1
cp mintegrate.tmp mintegrate.bak
last=0
while test $itask -le $ntask
do
   if [ $itask -gt $mtask ]
      then nitask=$minitask
      else nitask=$(($minitask + 1))
   fi
   fitask=`expr $litask + 1`
   litask=`expr $litask + $nitask`
   if [ $nitask -lt $niba0 ]
      then n=$nitask
      else n=$niba0
   fi
   if [ $n -lt 1 ]
      then n=1
   fi
   nbatask=$(($nitask / $n))
   nba=`expr $nba + $nbatask`
   image1=$(($fframe + $fitask - 1))

   echo $image1 $nitask $itask $nbatask >> forkintegrate.params
   last=$itask
   itask=`expr $itask + 1`
done
echo "submitting $last job array job" >> .forkintegrate.debug
qsub -sync y -p -10 -V -q ${queue} -cwd -pe smp 16 -t 1-$last \
${install}/forkintegrate_array_job >> .forkintegrate.debug.2 2>&1 

echo "Forkintegrate jobs all run at `date`" >> .forkintegrate.debug
rm -f mintegrate.tmp  

